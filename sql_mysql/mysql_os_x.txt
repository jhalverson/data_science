Jonathan Halverson
Wednesday, March 1, 2017
------------------------

### How to load the ufc data into mysql:

jhalverson$ mysql -u root -p

mysql> show databases;

mysql> use beverly;

mysql> show tables;

# cannot use keyword like From as column names
mysql> create table ufc (Name varchar(255), Nickname varchar(255), Active int, Record varchar(255), Age float, Height float, Weight float, Reach float, LegReach float, OutOf varchar(255), Hometown varchar(255), College varchar(255), Degree varchar(255), Summary varchar(255));

# needed the local keyword below to get this to work
load data local infile '/Users/jhalverson/data_science/misc/mma_analytics/ufc_dot_com_fighter_data_CLEAN_28Feb2017.csv' into table ufc fields terminated by ',' enclosed by '"' lines terminated by '\n' ignore 1 lines;

mysql> update ufc set Reach = null where Reach = 0;
mysql> update ufc set Height = null where Height = 0;
etc.

mysql> select Name, Record from ufc limit 5;
+---------------------+--------+
| Name                | Record |
+---------------------+--------+
| Danny Abbadi        |        |
| Tank Abbott         |        |
| Shamil Abdurakhimov | 17-4-0 |
| Papy Abedi          |        |
| Ricardo Abreu       | 5-1-0  |
+---------------------+--------+

mysql> desc ufc;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| Name     | varchar(255) | YES  |     | NULL    |       |
| Nickname | varchar(255) | YES  |     | NULL    |       |
| Active   | int(11)      | YES  |     | NULL    |       |
| Record   | varchar(255) | YES  |     | NULL    |       |
| Age      | float        | YES  |     | NULL    |       |
| Height   | float        | YES  |     | NULL    |       |
| Weight   | float        | YES  |     | NULL    |       |
| Reach    | float        | YES  |     | NULL    |       |
| LegReach | float        | YES  |     | NULL    |       |
| OutOf    | varchar(255) | YES  |     | NULL    |       |
| Hometown | varchar(255) | YES  |     | NULL    |       |
| College  | varchar(255) | YES  |     | NULL    |       |
| Degree   | varchar(255) | YES  |     | NULL    |       |
| Summary  | varchar(255) | YES  |     | NULL    |       |
+----------+--------------+------+-----+---------+-------+

mysql> select count(*) from ufc;
+----------+
| count(*) |
+----------+
|     1897 |
+----------+

mysql> select max(length(Summary)) from ufc;
+----------------------+
| max(length(Summary)) |
+----------------------+
|                  211 |
+----------------------+

### Check for duplicate names
mysql> select name, count(name) as ct from ufc group by name order by ct desc limit 5;
+------------------+----+
| name             | ct |
+------------------+----+
| Dong Hyun Kim    |  2 |
| John-Olav Einemo |  1 |
| Mikey Burnett    |  1 |
| Aaron Steed      |  1 |
| Jess Liaudin     |  1 |
+------------------+----+

### regular expressions (https://dev.mysql.com/doc/refman/5.7/en/regexp.html)
# all names beginning with a-e
select Name from ufc where Name regexp '^[a-e]';
# all names ending with a-e
select Name from ufc where Name regexp '[a-e]$';

mysql> select Name from ufc where Name regexp '[[:punct:]]';
+------------------------+
| Name                   |
+------------------------+
| Razak Al-Hassan        |
| Olivier Aubin-Mercier  |
| Nah-Shon Burrell       |
| J.C. Cottrell          |
| Richard Crunkilton Jr. |
| Abdul-Kerim Edilov     |
| John-Olav Einemo       |
| Ashlee Evans-Smith     |
| Xavier Foupa-Pokam     |
| He-Man Gipson          |
| Jocelyn Jones-Lybarger |
| C.J. Keith             |
| Jose Landi-Jons        |
| Jake O'Brien           |
| TJ O'Brien             |
| Sean O'Connell         |
| Chuck O'Neil           |
| Brendan O'Reilly       |
| Khalil Rountree Jr.    |
| Roldan Sangcha-an      |
| Georges St-Pierre      |
| Isaac Vallie-Flagg     |
+------------------------+

# throw away potential middle name
select c from (select concat(substring_index(name, ' ', 1), ' ', substring_index(name, ' ', -1)) as c from ufc) m where c like 'G%';

mysql> select count(LegReach), count(*) - count(Reach) as 'Null Reach' from ufc where Active=1;
+-----------------+------------+
| count(LegReach) | Null Reach |
+-----------------+------------+
|             449 |         29 |
+-----------------+------------+

mysql> select stddev(LegReach), count(LegReach), Avg(LegReach) from ufc;
+--------------------+-----------------+-------------------+
| stddev(LegReach)   | count(LegReach) | Avg(LegReach)     |
+--------------------+-----------------+-------------------+
| 2.4567404533132042 |             565 | 40.14513274336283 |
+--------------------+-----------------+-------------------+

# estimate of median (did not work correctly since gave 40 instead of 39)
mysql> select floor((select count(*) from ufc where legreach is not null)/2.);
+-----------------------------------------------------------------+
| floor((select count(*) from ufc where legreach is not null)/2.) |
+-----------------------------------------------------------------+
|                                                             282 |
+-----------------------------------------------------------------+
1 row in set (0.00 sec)

limit [offset, number of rows] so this is skipping the first 282 and then pulling one row
mysql> select legreach from ufc where legreach is not null order by legreach asc limit 282,1;
+----------+
| legreach |
+----------+
|       40 |
+----------+

mysql> select name, college, degree from ufc where degree not like '' or college not like '' order by name;
+------------------------+--------------------------------------------------+--------------------------------------------------------------------------+
| name                   | college                                          | degree                                                                   |
+------------------------+--------------------------------------------------+--------------------------------------------------------------------------+
| Aaron Phillips         | University of Louisiana at Lafayette             | Kinesiology-Exercise Science                                             |
| Aaron Simpson          | Arizona State University                         | Journalism                                                               |
| Abel Trujillo          | William Penn University                          | Sports Administration                                                    |
| Alan Omer              | Stuttgart University                             | Mechanical Engineering                                                   |
| Albert Cheng           |                                                  | Physical and Health Education                                            |
| Albert Tumenov         | University of Russia, Moscow                     | Bachelor Degree KBR                                                      |
| Alex Soto              | University of San Diego                          |                                                                          |
| Alptekin Ozkilic       | Missouri Baptist University                      | Business Administration                                                  |
| Andrew Craig           | University of Texas                              | Corporate Communications              

# case sensitive search
mysql> select name, Hometown from ufc where hometown regexp binary 'MA|Massachusetts';
+----------------+-----------------------------------------+
| name           | Hometown                                |
+----------------+-----------------------------------------+
| Kyle Bochniak  | Gloucester, Massachusetts USA           |
| Jason DeLucia  | Bellingham, Massachusetts USA           |
| Kenny Florian  | Westwood, Massachusetts USA             |
| Rob Font       | Leominster, Massachusetts USA           |
| Sean Gannon    | Boston, MA., MA. USA                    |
| Josh Grispi    | Boston, MA USA                          |
| John Howard    | Boston, Massachusetts USA               |
| Alex Karalexis | Boston, MA USA                          |
| Dan Lauzon     | Brockton, Massachusetts USA             |
| Joe Lauzon     | Brockton, Massachusetts USA             |
| Tom Lawlor     | Fall River, MA USA                      |
| Jon Manley     | Adams, MA USA                           |
| Chuck O'Neil   | Bourne, MA USA                          |
| Joe Proctor    | Quincy, Massachusetts USA               |
| Jimmy Quinlan  | Methuen, MA USA                         |
| Keith Rockel   | Marlboro, MA. USA                       |
| Charles Rosa   | Peabody, Massachusetts USA              |
| Eric Spicely   | Stoughton, Massachusetts USA            |
| Ken Stone      | Holliston, MA USA                       |
| Tecia Torres   | Fall River, Massachusetts United States |
| Patrick Walsh  | Boston, Massachusetts USA               |
+----------------+-----------------------------------------+

mysql> select weight, count(*), avg(age) from ufc where weight < 206 and active = 1 group by weight;
+--------+----------+--------------------+
| weight | count(*) | avg(age)           |
+--------+----------+--------------------+
|    115 |       38 | 28.666666666666668 |
|    125 |       25 |              28.24 |
|    135 |       73 | 29.986301369863014 |
|    140 |        2 |               32.5 |
|    145 |       58 |  29.43103448275862 |
|    155 |      101 |  30.08910891089109 |
|    170 |       94 | 30.795698924731184 |
|    185 |       55 | 31.636363636363637 |
|    205 |       45 | 31.244444444444444 |
+--------+----------+--------------------+















Jonathan Halverson
Thursday, June 23, 2016
-----------------------

### Make sure to start the server through system preferences
jhalverson$ mysql -p // with the server running

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| test               |
+--------------------+
2 rows in set (0.06 sec)

mysql> use test;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| persons        |
| test_log       |
+----------------+
2 rows in set (0.00 sec)


mysql> describe test.persons;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| id          | int(11)      | NO   | PRI | 0       |       |
| description | varchar(255) | YES  |     | NULL    |       |
| ContactName | varchar(255) | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

mysql> select * from persons;
+----+-------------------------------+----------------+
| id | description                   | ContactName    |
+----+-------------------------------+----------------+
| 11 | Gas canisters                 | James Woodborn |
| 56 | Digital compass for dog sleds | Charlie Parker |
+----+-------------------------------+----------------+
2 rows in set (0.07 sec)


mysql> describe test_log;
+-------------+--------------+------+-----+-------------+----------------+
| Field       | Type         | Null | Key | Default     | Extra          |
+-------------+--------------+------+-----+-------------+----------------+
| id          | int(11)      | NO   | PRI | NULL        | auto_increment |
| message     | varchar(255) | YES  |     | NULL        |                |
| ContactName | varchar(100) | YES  |     | Joey Baggio |                |
+-------------+--------------+------+-----+-------------+----------------+
3 rows in set (0.01 sec)


### delete a table
mysql> drop table test_log;
Query OK, 0 rows affected (0.28 sec)

mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| persons        |
+----------------+
1 row in set (0.00 sec)


### I tried to load a csv file but it failed due to jhalverson not having access
### I was able to make the table as jhalverson, however
mysql> create table products (ID int, ProductName varchar(255), ContactName varchar(255), Price float);
Query OK, 0 rows affected (0.22 sec)

### I then logged in as root and was then able to load the CSV file
nanomines:mysql jhalverson$ mysql -u root -p

load data infile "/Users/jhalverson/data_science/sql_mysql/products.csv" into table products columns terminated by ',' lines terminated by '\n';


mysql> create table suppliers (ID int unsigned primary key auto_increment, Supplier char(80) not null, ProductName char(80) not null, ContactEmail char(80) default 'contact@host.com');
Query OK, 0 rows affected (0.06 sec)

mysql> insert into suppliers (Supplier, ProductName) values ('Chips chips', 'Straws');                                      Query OK, 1 row affected (0.00 sec)

mysql> select * from suppliers;
+----+-------------+-------------+------------------+
| ID | Supplier    | ProductName | ContactEmail     |
+----+-------------+-------------+------------------+
|  1 | Chips chips | Straws      | contact@host.com |
+----+-------------+-------------+------------------+
1 row in set (0.00 sec)

### Joins
#The INNER JOIN creates a new result table by combining column values of two
#tables (table1 and table2) based upon the join-predicate. The query
#A full join is equivalent to a left join union all right join.
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | Supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
+----+----------------------+-------------------+------------------------+
4 rows in set (0.00 sec)

mysql> select * from products;
+------+----------------+---------------+--------+
| ID   | ProductName    | ContactName   | Price  |
+------+----------------+---------------+--------+
|    1 | Knives         | Joe Smith     |  19.99 |
|    2 | Spoons         | Karen McGue   |   2.38 |
|    3 | Fishbone Forks | Captain Joe   | 121.34 |
|    4 | Straws         | Mitch Cohawke |  33.99 |
+------+----------------+---------------+--------+
4 rows in set (0.00 sec)

mysql> select * from products left join suppliers on products.productname=suppliers.productname;
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
| ID   | ProductName    | ContactName   | Price  | ID   | Supplier             | ProductName | ContactEmail        |
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
|    4 | Straws         | Mitch Cohawke |  33.99 |    1 | Chips chips          | Straws      | info@chipschips.com |
|    1 | Knives         | Joe Smith     |  19.99 |    2 | Bed, Bath and Beyond | Knives      | help@b3.com         |
|    2 | Spoons         | Karen McGue   |   2.38 | NULL | NULL                 | NULL        | NULL                |
|    3 | Fishbone Forks | Captain Joe   | 121.34 | NULL | NULL                 | NULL        | NULL                |
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
4 rows in set (0.01 sec)

mysql> select * from products inner join suppliers on products.productname=suppliers.productname;
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
| ID   | ProductName | ContactName   | Price | ID | Supplier             | ProductName | ContactEmail        |
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
|    4 | Straws      | Mitch Cohawke | 33.99 |  1 | Chips chips          | Straws      | info@chipschips.com |
|    1 | Knives      | Joe Smith     | 19.99 |  2 | Bed, Bath and Beyond | Knives      | help@b3.com         |
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
2 rows in set (0.00 sec)



### Here is an alternative to describe:

mysql> desc products;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| ID          | int(11)      | YES  |     | NULL    |       |
| ProductName | varchar(255) | YES  |     | NULL    |       |
| ContactName | varchar(255) | YES  |     | NULL    |       |
| Price       | float        | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
4 rows in set (0.16 sec)


### Unicode
Nvarchar versus varchar

### SQL provides a variety of math functions

### Having
# The GROUP BY clause follows the WHERE clause in a SELECT statement and precedes the ORDER BY clause.
select country, sum(CustomerID) as sumfunc from customers group by country having sumfunc > 100 and Country like 'U%' order by sumfunc; 
Country	sumfunc
UK	213
USA	796


### use SQL as a calculator
select 45.0/2.98;


### any and all
SQL> SELECT * FROM CUSTOMERS
WHERE AGE > ALL (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
+----+--------+-----+-----------+---------+
| ID | NAME   | AGE | ADDRESS   | SALARY  |
+----+--------+-----+-----------+---------+
|  1 | Ramesh |  32 | Ahmedabad | 2000.00 |
+----+--------+-----+-----------+---------+
1 row in set (0.02 sec)
SQL> SELECT * FROM CUSTOMERS
WHERE AGE > ANY (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
+----+----------+-----+-----------+---------+
| ID | NAME     | AGE | ADDRESS   | SALARY  |
+----+----------+-----+-----------+---------+
|  1 | Ramesh   |  32 | Ahmedabad | 2000.00 |
|  2 | Khilan   |  25 | Delhi
|  4 | Chaitali |  25 | Mumbai
|  5 | Hardik   |  27 | Bhopal
+----+----------+-----+-----------+---------


### the like can be applied to numbers as well as text
select * from products where price like '_8';
# the percent symbol wildcard represents 0 or more characters


### Union, union all, intersect, except are all possible


### Started advanced operations
### Alter, truncate and other


### Create View view_name as select ...
# Note that a check clause can be added 
# There are many rules applied to views for updating and inserting rows
CREATE VIEW CUSTOMERS_VIEW AS
SELECT name, age FROM  CUSTOMERS WHERE age IS NOT NULL WITH CHECK OPTION;


### Monday, July 11, 2016
# If alias fails with where clase then use subquery (this is an inline view)
select * from (select productname, price as handle from products) as x where handle > 45 order by handle;

# concatenation in MySQL
select concat(description, '----', ContactName) from persons;
+-------------------------------------------------+
| concat(description, '----', ContactName)        |
+-------------------------------------------------+
| Gas canisters----James Woodborn                 |
| Digital compass for dog sleds----Charlie Parker |
+-------------------------------------------------+

# the case expression to add a column and use if-else
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | Supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
+----+----------------------+-------------------+------------------------+
5 rows in set (0.00 sec)

mysql> select productname, id, case when id > 75 then 'overpriced' when id <= 2 then 'underpriced' else 'okay' end as status from suppliers; 
+-------------------+----+-------------+
| productname       | id | status      |
+-------------------+----+-------------+
| Straws            |  1 | underpriced |
| Knives            |  2 | underpriced |
| Drill bits        |  3 | okay        |
| Ursula's Utensils |  4 | okay        |
| Manfrotto tripod  |  5 | okay        |
+-------------------+----+-------------+

# remove the not null constraint on a column
mysql> alter table suppliers modify supplier char(80) default null;

# replacing null in the result-set without changing the table
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |
+----+----------------------+-------------------+------------------------+
7 rows in set (0.00 sec)

# the coalesce function returns the first non-null results from left to right; if nothing
# is found then it returns null
mysql> select coalesce(supplier, 0) from suppliers;
+-----------------------+
| coalesce(supplier, 0) |
+-----------------------+
| Chips chips           |
| Bed, Bath and Beyond  |
| Grossmans             |
| Fishbone Forks        |
| Boston Warehouse      |
| Bills Trucking        |
| 0                     |
+-----------------------+

SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0)) FROM Products;

# order by number of column
select * from products order by 6 desc; // 6th column

# order by second to last character
mysql> select * from suppliers order by substr(productname, length(productname) - 1);
+----+----------------------+-------------------+------------------------+
| ID | supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  1 | Chips chips          | Straws            | info@chipschips.com    |
+----+----------------------+-------------------+------------------------+

# case statement for sorting

# Note: union will probabily internally use a sort to eliminiate duplicates

# using IN to select rows from a list of items from another table
select * from customers where customers.country in (select distinct suppliers.country from suppliers) order by customers.country;
select * from customers where customers.country not in (select distinct suppliers.country from suppliers) order by customers.country;

# wildcard select
select c.* from customers as c;


###Tuesday, July 12, 2016
# all, any, some
SELECT e1.empno, e1.sal
FROM   emp e1
WHERE  e1.sal > ALL (SELECT e2.sal
                     FROM   emp e2
                     WHERE  e2.deptno = 20);

# CLOB is a character large object -- maybe replaced by text
# There are five data types that deal with dates and times: date, time w/o time zone, timestamp w/o time zone
# Intervals analogous to timediff are available
# Row types breaks the rule of only one value per field
# First normal form
# Array and multiset is also possible Create table customer (Phone character varying (15) array[3]);
# Cardinality relates to array size
# REF is a pointer which can be dereferenced to obtain the actual contents
# UDT or user defined types are also possible - these are nice because one can match the data types
# of the host (application) with those of the database. UDT include distinct types and structured types
# Distinct types are like typedefs from C/C++
# XML can be stored
# Schemas contain tables and views


### Wednesday, July 13, 2016
# Adding a column dependent on current columns
select * from (select customername, city, case when city > 'L' then 0 else 1 end as city_flag from customers) as x where city_flag=1;
customername	city	city_flag
Alfreds Futterkiste	Berlin	1
Cactus Comidas para llevar	Buenos Aires	1
Chop-suey Chinese	Bern	1
Drachenblut Delikatessend	Aachen	1

# using an line case clause
select *, price*case when price < 10 then 0.1 when price < 20 then 1 when price > 20 then 1.6 end as scaled_price from products;

mysql> select *, power(id, 2) from suppliers;
+----+----------------------+-------------------+------------------------+--------------+
| ID | supplier             | ProductName       | ContactEmail           | power(id, 2) |
+----+----------------------+-------------------+------------------------+--------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |            1 |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |            4 |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |            9 |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |           16 |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |           25 |
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |           36 |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |           49 |
+----+----------------------+-------------------+------------------------+--------------+

# find common rows between tables
select * from charles # where charles is a view with rows in customers with customerid > 50
intersect
select * from customers;

# find rows in the first table which do not exist in the second
select * from customers
except
select * from charles;


### Friday, July 15, 2016
select categoryID, supplierid, avg(price), count(supplierid) from products where supplierid < 100 group by categoryID, supplierid having avg(price) > 25 order by categoryID desc;

# join with "using" instead of "on"
select * from customers join orders using (customerid);

A database contains catalogs which contain schemas which contain tables

CREATE SCHEMA SALES AUTHORIZATION SALES_MANAGER DEFAULT CHARACTER SET ASCII_FULL;

CREATE DOMAIN AGE AS INTEGER CHECK (AGE > 20)

DDL (data definition), DML (data manipulation lang), DCL (control)

Aggregate or set functions: avg, min, max, sum, count - these operate on columns instead
of the scalar functions.

DCL has commit, rollback, grant, revoke

Collation is how strings compare with one another for a given character set.

Composite keys as primary keys


### Monday, July 18, 2016
mysql> select county, avg(tiv_2012) from insur where county between 'A%' and 'H%' group by county having avg(tiv_2012) > 300000.0 order by county;
+------------------+----------------+
| county           | avg(tiv_2012)  |
+------------------+----------------+
| ALACHUA COUNTY   | 1021623.785457 |
| BAY COUNTY       | 3013689.310074 |
| BRADFORD COUNTY  | 1177371.827097 |
| BREVARD COUNTY   | 1939929.287844 |
| BROWARD COUNTY   | 2690955.647285 |
| CALHOUN COUNTY   |  715649.379706 |
| CHARLOTTE COUNTY | 1459168.163333 |
| CITRUS COUNTY    | 1018138.243984 |
| CLAY COUNTY      |  716967.506942 |
| COLLIER COUNTY   | 2419465.874003 |
| COLUMBIA COUNTY  | 1454704.909840 |
| DESOTO COUNTY    |  596621.362870 |
| DIXIE COUNTY     |  559451.452000 |
| DUVAL COUNTY     | 3262571.100011 |
| ESCAMBIA COUNTY  | 2309973.569818 |
| FLAGLER COUNTY   | 1152014.854167 |
| FRANKLIN COUNTY  |  756127.959730 |
| GADSDEN COUNTY   |  903971.397704 |
| GILCHRIST COUNTY |  314619.013333 |
| GLADES COUNTY    | 1010138.583636 |
| GULF COUNTY      |  854822.123472 |
+------------------+----------------+
21 rows in set (0.05 sec)

select policy_id, tiv_2011, tiv_2012 from insur where county = any(select county from insur where county like 'L%');


###Tuesday, July 19, 2016
# working with dates

mysql> select curdate();
+------------+
| curdate()  |
+------------+
| 2016-07-19 |
+------------+
1 row in set (0.00 sec)

mysql> select curtime();
+-----------+
| curtime() |
+-----------+
| 11:48:38  |
+-----------+
1 row in set (0.00 sec)

mysql> select now();
+---------------------+
| now()               |
+---------------------+
| 2016-07-19 11:48:45 |
+---------------------+
1 row in set (0.00 sec)

TIP: The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database.

For instance, the query "SELECT * FROM Orders WHERE OrderDate='2008-11-11'" will not return anything from
1	Geitost	2008-11-11 13:23:44
2	Camembert Pierrot	2008-11-09 15:45:21
3	Mozzarella di Giovanni	2008-11-11 11:12:01
4	Mascarpone Fabioli	2008-10-29 14:56:59

because the query is looking for dates with no time portion.

###
mysql> select * from orders where orderdate1 = '2016-07-19';
Empty set (0.00 sec)

mysql> select * from orders where orderdate2 = '2016-07-19';
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 |
+----+---------------------+------------+---------------------+-------+
1 row in set (0.00 sec)

mysql> select * from orders where orderdate3 = '2016-07-19';
Empty set (0.00 sec)
###

As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets complicated.

NOW()	Returns the current date and time
CURDATE()	Returns the current date
CURTIME()	Returns the current time
DATE()	Extracts the date part of a date or date/time expression
EXTRACT()	Returns a single part of a date/time
DATE_ADD()	Adds a specified time interval to a date
DATE_SUB()	Subtracts a specified time interval from a date
DATEDIFF()	Returns the number of days between two dates
DATE_FORMAT()	Displays date/time data in different formats

MySQL comes with the following data types for storing a date or a date/time value in the database:

DATE - format YYYY-MM-DD
DATETIME  - format: YYYY-MM-DD HH:MI:SS
TIMESTAMP - format: YYYY-MM-DD HH:MI:SS
YEAR - format YYYY or YY

select * from orders where orders.orderdate > '1996-09-04';
select avg(orderdate) from orders; 1996.2244897959183

mysql> select datediff('1999-05-22', '1996-07-11');
+--------------------------------------+
| datediff('1999-05-22', '1996-07-11') |
+--------------------------------------+
|                                 1045 |
+--------------------------------------+

mysql> select datediff('1996-07-11', '1999-05-22');
+--------------------------------------+
| datediff('1996-07-11', '1999-05-22') |
+--------------------------------------+
|                                -1045 |
+--------------------------------------+

mysql> select date_add('1996-07-11', interval 60 day);
+-----------------------------------------+
| date_add('1996-07-11', interval 60 day) |
+-----------------------------------------+
| 1996-09-09                              |
+-----------------------------------------+

mysql> select date_add('1996-07-11', interval (select datediff('1999-07-11', '1996-05-22')) day);
+------------------------------------------------------------------------------------+
| date_add('1996-07-11', interval (select datediff('1999-07-11', '1996-05-22')) day) |
+------------------------------------------------------------------------------------+
| 1999-08-30                                                                         |
+------------------------------------------------------------------------------------+

mysql> select EXTRACT(year from '1999-07-11') + 999;
+---------------------------------------+
| EXTRACT(year from '1999-07-11') + 999 |
+---------------------------------------+
|                                  2998 |
+---------------------------------------+

mysql> select extract(year from date('2014-11-22 13:23:44.657'));
+----------------------------------------------------+
| extract(year from date('2014-11-22 13:23:44.657')) |
+----------------------------------------------------+
|                                               2014 |
+----------------------------------------------------+

mysql> select DATE_FORMAT(NOW(),'%d %b %Y %T:%f');
+-------------------------------------+
| DATE_FORMAT(NOW(),'%d %b %Y %T:%f') |
+-------------------------------------+
| 19 Jul 2016 13:02:22:000000         |
+-------------------------------------+

mysql> select DATE_FORMAT('2014-11-22 13:23:44.657','%d %b %Y %T:%f');
+---------------------------------------------------------+
| DATE_FORMAT('2014-11-22 13:23:44.657','%d %b %Y %T:%f') |
+---------------------------------------------------------+
| 22 Nov 2014 13:23:44:657000                             |
+---------------------------------------------------------+

Even if DATETIME and TIMESTAMP return the same format, they work very differently. In an INSERT or UPDATE query, the TIMESTAMP automatically set itself to the current date and time. TIMESTAMP also accepts various formats, like YYYYMMDDHHMISS, YYMMDDHHMISS, YYYYMMDD, or YYMMDD.

# make a table with date/time data types
mysql> create table orders (id int primary key, orderdate1 timestamp, orderdate2 date, orderdate3 datetime, price float);

mysql> insert into orders values(1, now(), '2016-07-19', now(), 34.75);
Query OK, 1 row affected (0.02 sec)

mysql> insert into orders values(2, '2002-07-10 10:07:05', '2050-03-07', '2000-05-15 15:05:00', 12.50);
Query OK, 1 row affected (0.05 sec)

mysql> select * from orders;
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 |
+----+---------------------+------------+---------------------+-------+

mysql> desc orders;
+------------+-----------+------+-----+-------------------+-----------------------------+
| Field      | Type      | Null | Key | Default           | Extra                       |
+------------+-----------+------+-----+-------------------+-----------------------------+
| id         | int(11)   | NO   | PRI | NULL              |                             |
| orderdate1 | timestamp | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
| orderdate2 | date      | YES  |     | NULL              |                             |
| orderdate3 | datetime  | YES  |     | NULL              |                             |
| price      | float     | YES  |     | NULL              |                             |
+------------+-----------+------+-----+-------------------+-----------------------------+

mysql> select * from orders where extract(year from date(orderdate1)) = 2012;
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 |
+----+---------------------+------------+---------------------+-------+

mysql> select datediff(orderdate1, orderdate2) from orders;
+----------------------------------+
| datediff(orderdate1, orderdate2) |
+----------------------------------+
|                                0 |
|                           -17407 |
|                             2369 |
+----------------------------------+


mysql> select @x:=avg(orderdate2) from orders;
+---------------------+
| @x:=avg(orderdate2) |
+---------------------+
|  20237343.000000000 |
+---------------------+

mysql> select *, @x from orders;
+----+---------------------+------------+---------------------+-------+--------------------+
| id | orderdate1          | orderdate2 | orderdate3          | price | @x                 |
+----+---------------------+------------+---------------------+-------+--------------------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 | 20237343.000000000 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 | 20237343.000000000 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 | 20237343.000000000 |
+----+---------------------+------------+---------------------+-------+--------------------+

mysql> select *, @x - datediff(orderdate1, orderdate2) from orders;
+----+---------------------+------------+---------------------+-------+-----------------------------------------+
| id | orderdate1          | orderdate2 | orderdate3          | price | @x - datediff(orderdate1, orderdate2)   |
+----+---------------------+------------+---------------------+-------+-----------------------------------------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 | 20237343.000000000000000000000000000000 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 | 20254750.000000000000000000000000000000 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 | 20234974.000000000000000000000000000000 |
+----+---------------------+------------+---------------------+-------+-----------------------------------------+


### Wednesday, July 20, 2016
On indexes, rows are stored in the order they are inserted. An index simply list the rows by a specific column in order and stores the row index as pointer to the table.

# only need table qualifier when column name is the same between tables
select customers.customerid, orderdate, Country from customers, orders using (customerid);

You can't update expressions in views; only columns in the underlying tables

select * from customers limit 10 offset 5;

Merge is a statement to conditionally insert values

Temporal data - PERIOD -> application time (which dept an employee worked in) vs. system time (bank transactions)

select city, case when city < 'D' then 1 when city < 'P' then 2 else 3 end as code from customers order by code;

select * from customers where customerid > (select avg(price) from products);

# select columns from tables [join] [where] [group by] [having] [order by]
select customerid, city, orderid from customers inner join orders using (customerid) where customerid > 50 and orderid > 10260;


### Thursday, July 21, 2016
select * from customers order by City, CustomerName desc, Address;
select * from customers order by 5, 2 desc, 4;
select * from products where price > 1.25 * (select avg(price) from products);
select * from products where price > 50 and not supplierid = 3;
null does not equal null (must use is null)

select price, price < 20, productid is null from products;
Price	price < 20	productid is null
18	1	0
19	1	0
10	1	0
22	0	0
21.35	0	0

To escape characters like _ and % use ! like '100!%'
where quote like '20#%' escape '#'; // # must not appear in the string

Derived columns are like: select name, heigh, 2*height from bodies;
select productname || 'out' as concated from products where price between 3.5 and 75; // concatenation
select City || ', ' || Country as Address from customers;
select City || ', ' || trim(Country) as Address from customers; // chars are padded so use trim


### Friday, July 22, 2016
mysql> select county, substring(county from 3) from insur_ limit 3;
+----------------+--------------------------+
| county         | substring(county from 3) |
+----------------+--------------------------+
| BROWARD COUNTY | OWARD COUNTY             |
| CITRUS COUNTY  | TRUS COUNTY              |
| DUVAL COUNTY   | VAL COUNTY               |
+----------------+--------------------------+

mysql> select county, substring(county from 3 for 5) from insur_ limit 3;
+----------------+--------------------------------+
| county         | substring(county from 3 for 5) |
+----------------+--------------------------------+
| BROWARD COUNTY | OWARD                          |
| CITRUS COUNTY  | TRUS                           |
| DUVAL COUNTY   | VAL C                          |
+----------------+--------------------------------+

mysql> select distinct county from insur_ where county like 'b%'; // notice not case-sensitive for this SQL engine
+-----------------+
| county          |
+-----------------+
| BROWARD COUNTY  |
| BAY COUNTY      |
| BREVARD COUNTY  |
| BAKER COUNTY    |
| BRADFORD COUNTY |
+-----------------+

mysql> select county, char_length(county), length(county), character_length(county) from insur_ limit 5;
+-----------------+---------------------+----------------+--------------------------+
| county          | char_length(county) | length(county) | character_length(county) |
+-----------------+---------------------+----------------+--------------------------+
| BROWARD COUNTY  |                  14 |             14 |                       14 |
| CITRUS COUNTY   |                  13 |             13 |                       13 |
| DUVAL COUNTY    |                  12 |             12 |                       12 |
| OKALOOSA COUNTY |                  15 |             15 |                       15 |
| SARASOTA COUNTY |                  15 |             15 |                       15 |
+-----------------+---------------------+----------------+--------------------------+

# position returns the position of the first occurance of the substring
mysql> select distinct county, position('H CO' in county) from insur_ where position('H CO' in county) <> 0;
+---------------------+----------------------------+
| county              | position('H CO' in county) |
+---------------------+----------------------------+
| HILLSBOROUGH COUNTY |                         12 |
| PALM BEACH COUNTY   |                         10 |
+---------------------+----------------------------+

mysql> select current_user();
+----------------------+
| current_user()       |
+----------------------+
| jhalverson@localhost |
+----------------------+

mysql> select current_date;
+--------------+
| current_date |
+--------------+
| 2016-07-22   |
+--------------+

mysql> select DATE_ADD(current_date, INTERVAL 90 day);
+-----------------------------------------+
| DATE_ADD(current_date, INTERVAL 90 day) |
+-----------------------------------------+
| 2016-10-20                              |
+-----------------------------------------+

# cast
select cast(price as integer) from products;
select cast(tiv_2012 as signed) from insur_; // Use signed instead of integer in MySQL

mysql> select char_length(cast(tiv_2012 as char(20))) from insur_ limit 5;
+-----------------------------------------+
| char_length(cast(tiv_2012 as char(20))) |
+-----------------------------------------+
|                                       8 |
|                                       7 |
|                                       9 |
|                                       8 |
|                                       9 |
+-----------------------------------------+

mysql> select county, case when position('BRO' in county) <> 0 then 'Bro' else 'Not Bro' end from insur_ limit 5;
+-----------------+------------------------------------------------------------------------+
| county          | case when position('BRO' in county) <> 0 then 'Bro' else 'Not Bro' end |
+-----------------+------------------------------------------------------------------------+
| BROWARD COUNTY  | Bro                                                                    |
| CITRUS COUNTY   | Not Bro                                                                |
| DUVAL COUNTY    | Not Bro                                                                |
| OKALOOSA COUNTY | Not Bro                                                                |
| SARASOTA COUNTY | Not Bro                                                                |
+-----------------+------------------------------------------------------------------------+

# successive joins or chaining
select * from customers inner join orders on customers.customerid=orders.customerid and customers.customerid > 50 inner join orderdetails on orderdetails.orderid=orders.orderid;


# join with and condition
select * from customers inner join orders on customers.customerid=orders.customerid and customers.customerid > 50;

nullif is useful to replace -1 or 99 or 'N/A' with null
Ex: select nullif(job, -1) this returns null if job is -1 or job is it is not equal to -1

A domain is a set of permissible values for a column.

# joins (Chapter 7)
select * from customers natural join orders natural join shippers; // compares columns with the same name for equality


### Monday, July 25, 2016
A null is not a match when joining.

The cross join is the Cartesian product or every row with every row.

The using clause is similar to natural join except with using you can specify which columns
should match whereas with natural it will compare all columns with the same name for equality.
select * from table1 join_type table2 using (column1, column2);

Use cross join or Cartesian product: select * from table1 cross join table 2;
Be wary of natural joins because if column names are renamed then previously written scripts can fail.

Join is equivalent to inner join since it is the most common.

inner join on t.price * t.sales > 10 * r.advance and t.title_id = r.title_id
and t.title_id = r.title_id; // list books whose revenue is ten times larger than its advance

select o1.orderdetailid, o2.productid from orderdetails as o1 inner join orderdetails as o2 on o1.orderdetailid=o2.productid;


### Tuesday, July 26, 2016
# Subqueries
select * from insur_ where county in (select county from insur_ where tiv_2012 > 1500000000.0);

select * from insur_ where tiv_2012 >= (select max(tiv_2012) from insur_ where construction='Wood');

Simple subqueries versus correlated subqueries. Here is a correlated subquery where
a column of the table in outer query appears in the condition of the inner query.

select c.* from customers as c where 10240 + customerid in (select orderid from orders where c.customerid=orders.customerid);
CustomerID	CustomerName	ContactName	Address	City	PostalCode	Country
14	Chop-suey Chinese	Yang Wang	Hauptstr. 29	Bern	3012	Switzerland
24	Folk och fä HB	Maria Larsson	Åkergatan 24	Bräcke	S-844 67	Sweden
44	Lehmanns Marktstand	Renate Messner	Magazinweg 7	Frankfurt a.M.	60528	Germany


### Wednesday, July 27, 2016
# Read chapter on set operations
# Completed set operations

### Friday, July 29, 2016
Use order by at the very end of union, intersection, except

To calculate a running average use a cross join with an inequality in the where clause and then group by

### Saturday, July 30, 2016
select * from insur_ where rand() < 0.01; // mysql approach to get a random sample of rows

select distinct * from customers; // checking for duplicates
Or to look for duplicates using composite fields:
mysql> select supplier, productname, count(*) from suppliers group by supplier, productname having count(*) >= 1;
+----------------------+-------------------+----------+
| supplier             | productname       | count(*) |
+----------------------+-------------------+----------+
| NULL                 | Cargo service     |        1 |
| Bed, Bath and Beyond | Knives            |        1 |
| Bills Trucking       | cargo service     |        2 |
| Boston Warehouse     | Manfrotto tripod  |        1 |
| Chips chips          | Straws            |        1 |
| Fishbone Forks       | Ursula's Utensils |        1 |
| Grossmans            | Drill bits        |        1 |
+----------------------+-------------------+----------+

### Monday, August 1, 2016
Running average:

mysql> select * from insur_mini;
+-----------+---------------------+-------------+-------------+---------------------+
| policy_id | county              | tiv_2011    | tiv_2012    | construction        |
+-----------+---------------------+-------------+-------------+---------------------+
|    100074 | BROWARD COUNTY      |    44665.57 |    36878.76 | Wood                |
|    100123 | CITRUS COUNTY       |     4374.00 |     6774.39 | Wood                |
|    100141 | DUVAL COUNTY        |   494802.00 |   559055.01 | Masonry             |
|    100183 | OKALOOSA COUNTY     |    52032.55 |    75451.36 | Wood                |
|    100203 | SARASOTA COUNTY     |   220993.74 |   314625.69 | Wood                |
|    100208 | COLLIER COUNTY      |  2187352.81 |  2004315.13 | Reinforced Masonry  |
|    100316 | GADSDEN COUNTY      |   112828.37 |   124303.92 | Wood                |
|    100318 | LAKE COUNTY         | 16920000.00 | 24570000.00 | Reinforced Concrete |
|    100361 | MIAMI DADE COUNTY   |  5391882.17 |  7972037.97 | Reinforced Masonry  |
|    100377 | MARION COUNTY       |    44908.51 |    43112.17 | Wood                |
|    100403 | WALTON COUNTY       |    23031.00 |    39940.61 | Wood                |
|    100406 | VOLUSIA COUNTY      |      404.76 |      329.46 | Wood                |
|    100433 | COLLIER COUNTY      |   757350.00 |   839901.91 | Masonry             |
|    100440 | COLLIER COUNTY      |    12865.48 |    19688.58 | Wood                |
|    100464 | ORANGE COUNTY       |   685903.50 |   952174.67 | Masonry             |
|    100486 | SANTA ROSA COUNTY   |   500148.00 |   700452.27 | Masonry             |
|    100491 | MIAMI DADE COUNTY   |   212163.86 |   236011.08 | Wood                |
|    100548 | POLK COUNTY         |   716757.55 |  1038151.64 | Masonry             |
|    100552 | ESCAMBIA COUNTY     |  1142758.99 |   931120.02 | Masonry             |
|    100557 | HILLSBOROUGH COUNTY |    16917.01 |    20223.01 | Wood                |
+-----------+---------------------+-------------+-------------+---------------------+

mysql> select a.policy_id a_id, a.tiv_2012 a_tiv, b.policy_id b_id, b.tiv_2012 b_tiv from insur_mini a, insur_mini b where a.policy_id >= b.policy_id order by a_id;
+--------+-------------+--------+-------------+
| a_id   | a_tiv       | b_id   | b_tiv       |
+--------+-------------+--------+-------------+
| 100074 |    36878.76 | 100074 |    36878.76 |
| 100123 |     6774.39 | 100074 |    36878.76 |
| 100123 |     6774.39 | 100123 |     6774.39 |
| 100141 |   559055.01 | 100074 |    36878.76 |
| 100141 |   559055.01 | 100141 |   559055.01 |
| 100141 |   559055.01 | 100123 |     6774.39 |
| 100183 |    75451.36 | 100123 |     6774.39 |
| 100183 |    75451.36 | 100074 |    36878.76 |
| 100183 |    75451.36 | 100183 |    75451.36 |
| 100183 |    75451.36 | 100141 |   559055.01 |
| 100203 |   314625.69 | 100123 |     6774.39 |
| 100203 |   314625.69 | 100074 |    36878.76 |
| 100203 |   314625.69 | 100183 |    75451.36 |
| 100203 |   314625.69 | 100141 |   559055.01 |
| 100203 |   314625.69 | 100203 |   314625.69 |
...

mysql> select a.policy_id, avg(b.tiv_2012) from insur_mini a, insur_mini b where a.policy_id >= b.policy_id group by a.policy_id;
+-----------+-----------------+
| policy_id | avg(b.tiv_2012) |
+-----------+-----------------+
|    100074 |    36878.760000 |
|    100123 |    21826.575000 |
|    100141 |   200902.720000 |
|    100183 |   169539.880000 |
|    100203 |   198557.042000 |
|    100208 |   499516.723333 |
|    100316 |   445914.894286 |
|    100318 |  3461425.532500 |
|    100361 |  3962604.692222 |
|    100377 |  3570655.440000 |
|    100403 |  3249681.364545 |
|    100406 |  2978902.039167 |
|    100433 |  2814363.567692 |
|    100440 |  2614743.925714 |
|    100464 |  2503905.975333 |
|    100486 |  2391190.118750 |
|    100491 |  2264414.881176 |
|    100548 |  2196289.145556 |
|    100552 |  2129701.296842 |
|    100557 |  2024227.382500 |
+-----------+-----------------+

# trimmed mean -- ignore the 3 largest and smallest values
mysql> select avg(a.tiv_2012) from insur_mini a where (select count(*) from insur_mini b where a.tiv_2012 >= b.tiv_2012) >= 3 and (select count(*) from insur_mini c where a.tiv_2012 <= c.tiv_2012) >= 3;
+-----------------+
| avg(a.tiv_2012) |
+-----------------+
|   495962.864375 |
+-----------------+

mysql> select avg(tiv_2012) from insur_mini;
+----------------+
| avg(tiv_2012)  |
+----------------+
| 2024227.382500 |
+----------------+

mysql> select avg(a.tiv_2012) from insur_mini a where (select count(*) from insur_mini b where a.tiv_2012 >= b.tiv_2012) >= 0 and (select count(*) from insur_mini c where a.tiv_2012 <= c.tiv_2012) >= 0;
+-----------------+
| avg(a.tiv_2012) |
+-----------------+
|  2024227.382500 |
+-----------------+

# Tried to make a sequence but apparently MySQL does not support them.

select policy_id, case when construction='Wood' then 'Cedar' when construction='Masonry' then 'Cheddar' else construction end from insur_mini;
+-----------+-------------------------------------------------------------------------------------------------------------+
| policy_id | case when construction='Wood' then 'Cedar' when construction='Masonry' then 'Cheddar' else construction end |
+-----------+-------------------------------------------------------------------------------------------------------------+
|    100074 | Cedar                                                                                                       |
|    100123 | Cedar                                                                                                       |
|    100141 | Cheddar                                                                                                     |
|    100183 | Cedar                                                                                                       |
|    100203 | Cedar                                                                                                       |
|    100208 | Reinforced Masonry                                                                                          |
|    100316 | Cedar                                                                                                       |
|    100318 | Reinforced Concrete                                                                                         |
|    100361 | Reinforced Masonry                                                                                          |
|    100377 | Cedar                                                                                                       |
|    100403 | Cedar                                                                                                       |
|    100406 | Cedar                                                                                                       |
|    100433 | Cheddar                                                                                                     |
|    100440 | Cedar                                                                                                       |
|    100464 | Cheddar                                                                                                     |
|    100486 | Cheddar                                                                                                     |
|    100491 | Cedar                                                                                                       |
|    100548 | Cheddar                                                                                                     |
|    100552 | Cheddar                                                                                                     |
|    100557 | Cedar                                                                                                       |
+-----------+-------------------------------------------------------------------------------------------------------------+

# Assigning rank
mysql> select policy_id, tiv_2012, (select count(*) from insur_mini b where a.tiv_2012 >= b.tiv_2012) from insur_mini a;
+-----------+-------------+--------------------------------------------------------------------+
| policy_id | tiv_2012    | (select count(*) from insur_mini b where a.tiv_2012 >= b.tiv_2012) |
+-----------+-------------+--------------------------------------------------------------------+
|    100074 |    36878.76 |                                                                  5 |
|    100123 |     6774.39 |                                                                  2 |
|    100141 |   559055.01 |                                                                 12 |
|    100183 |    75451.36 |                                                                  8 |
|    100203 |   314625.69 |                                                                 11 |
|    100208 |  2004315.13 |                                                                 18 |
|    100316 |   124303.92 |                                                                  9 |
|    100318 | 24570000.00 |                                                                 20 |
|    100361 |  7972037.97 |                                                                 19 |
|    100377 |    43112.17 |                                                                  7 |
|    100403 |    39940.61 |                                                                  6 |
|    100406 |      329.46 |                                                                  1 |
|    100433 |   839901.91 |                                                                 14 |
|    100440 |    19688.58 |                                                                  3 |
|    100464 |   952174.67 |                                                                 16 |
|    100486 |   700452.27 |                                                                 13 |
|    100491 |   236011.08 |                                                                 10 |
|    100548 |  1038151.64 |                                                                 17 |
|    100552 |   931120.02 |                                                                 15 |
|    100557 |    20223.01 |                                                                  4 |
+-----------+-------------+--------------------------------------------------------------------+

select policy_id, tiv_2012 from insur_mini order by tiv_2012;
+-----------+-------------+
| policy_id | tiv_2012    |
+-----------+-------------+
|    100406 |      329.46 |
|    100123 |     6774.39 |
|    100440 |    19688.58 |
|    100557 |    20223.01 |
|    100074 |    36878.76 |
|    100403 |    39940.61 |
|    100377 |    43112.17 |
|    100183 |    75451.36 |
|    100316 |   124303.92 |
|    100491 |   236011.08 |
|    100203 |   314625.69 |
|    100141 |   559055.01 |
|    100486 |   700452.27 |
|    100433 |   839901.91 |
|    100552 |   931120.02 |
|    100464 |   952174.67 |
|    100548 |  1038151.64 |
|    100208 |  2004315.13 |
|    100361 |  7972037.97 |
|    100318 | 24570000.00 |
+-----------+-------------+

Temporary tables are destroyed at the end of a session. They are useful since one can prevent
users from having base tables which they can overload, alter, etc. MySQL does not recognize
the local and global temporary tables.

Temporary tables are different than views and using create table as select * from table where x

View
+ may be assembled from base tables, temporary tables or other views
+ stored as a select statement and not the actual data
+ views can be updated if their rows come from a single base table without group by, having, distinct

Chapter 14: Transactions
A transactions is a set of one or more SQL statement executed as a single logical unit. They
can be commited or rolled back, which means all statements and data changes are reversed. Seems
useful in the banking business where a power outage for instance can cause a change in an account
in a suspicous way.


### Tuesday, August 2, 2016
The aggregate function count ignores null values.

One can define variables or parameters and then use them via :param1

mysql> select @x:=10.413;
+------------+
| @x:=10.413 |
+------------+
|     10.413 |
+------------+

mysql> select county, @x from insur_mini;
+---------------------+--------+
| county              | @x     |
+---------------------+--------+
| BROWARD COUNTY      | 10.413 |
| CITRUS COUNTY       | 10.413 |
| DUVAL COUNTY        | 10.413 |
...

mysql> SET @t1=1, @t2=2, @t3:=4;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @t1, @t2, @t3, @t4 := @t1+@t2+@t3;
+------+------+------+--------------------+
| @t1  | @t2  | @t3  | @t4 := @t1+@t2+@t3 |
+------+------+------+--------------------+
|    1 |    2 |    4 |                  7 |
+------+------+------+--------------------+

SQL has functions that use regular expressions like position_regex()


### Wednesday, August 3, 2016
Be careful when comparing id's that are stored as integers in one table and character arrays in another.

Row value expression:
mysql> select * from insur_mini where (county, construction) = ('COLLIER COUNTY', 'Wood');
+-----------+----------------+----------+----------+--------------+
| policy_id | county         | tiv_2011 | tiv_2012 | construction |
+-----------+----------------+----------+----------+--------------+
|    100440 | COLLIER COUNTY | 12865.48 | 19688.58 | Wood         |
+-----------+----------------+----------+----------+--------------+

Similar is a predicate where you can compare a character string to a regular expression.

Be careful with any and null values

select * from customers where exists (select * from orders where orders.customerid=customers.customerid); // 74 rows
select * from customers where 0 <> (select count(*) from orders where orders.customerid=customers.customerid); // 74 rows
select * from customers, orders where orders.customerid=customers.customerid; // 196 which is cardinality of orders
select distinct customerid from orders; // 74 rows
SELECT * FROM [Customers] where not (city='London');

Unique is like exists but it evaluate to true if no two rows are the same.

Overlaps may be used to determine if two time intervals overlap

Match can be used for referential integrity

select categoryid, avg(price) as mean_price from products group by categoryid having categoryid>=3 and mean_price < 30;

SQL 1999 introduced a means for using windows

Corresponding can be used with union to combine columns with the same names in both tables.

A natural joins considers a match when both the column names, types and lengths are equal.

// triple join
select * from customers c left outer join orders o on c.customerid=o.customerid left outer join shippers s on s.shipperid=o.shipperid;

CustomerID	CustomerName	ContactName	Address	City	PostalCode	Country	OrderID	EmployeeID	OrderDate	ShipperID	ShipperName	Phone
null	Alfreds Futterkiste	Maria Anders	Obere Str. 57	Berlin	12209	Germany	null	null	null	null	null	null
2	Ana Trujillo Emparedados y helados	Ana Trujillo	Avda. de la Constitución 2222	México D.F.	05021	Mexico	10308	7	1996-09-18	3	Federal Shipping	(503) 555-9931
3	Antonio Moreno Taquería	Antonio Moreno	Mataderos 2312	México D.F.	05023	Mexico	10365	3	1996-11-27	2	United Package	(503) 555-3199
4	Around the Horn	Thomas Hardy	120 Hanover Sq.	London	WA1 1DP	UK	10355	6	1996-11-15	1	Speedy Express	(503) 555-9831

There appears to be no union join in MySQL.

mysql> select * from insur_mini where tiv_2012 > all(select tiv_2012 from insur where construction='wood');
+-----------+-------------------+-------------+-------------+---------------------+
| policy_id | county            | tiv_2011    | tiv_2012    | construction        |
+-----------+-------------------+-------------+-------------+---------------------+
|    100208 | COLLIER COUNTY    |  2187352.81 |  2004315.13 | Reinforced Masonry  |
|    100318 | LAKE COUNTY       | 16920000.00 | 24570000.00 | Reinforced Concrete |
|    100361 | MIAMI DADE COUNTY |  5391882.17 |  7972037.97 | Reinforced Masonry  |
|    100433 | COLLIER COUNTY    |   757350.00 |   839901.91 | Masonry             |
|    100464 | ORANGE COUNTY     |   685903.50 |   952174.67 | Masonry             |
|    100486 | SANTA ROSA COUNTY |   500148.00 |   700452.27 | Masonry             |
|    100548 | POLK COUNTY       |   716757.55 |  1038151.64 | Masonry             |
|    100552 | ESCAMBIA COUNTY   |  1142758.99 |   931120.02 | Masonry             |
+-----------+-------------------+-------------+-------------+---------------------+

### Friday, August 5, 2016
Read chapter on controlling operations

### Monday, August 8, 2016
Read chapter on recursive queries which is not part of the standard

### Tuesday, August 9, 2016
Controlling operations with security
grant insert on customer to SalesClerk; // revoke update on customer from SalesClerk;
Domains are like typedefs with checks, so user defined types with check constraints
Triggers are like signals in that they allow for code to be executed when a certain event happens. The
code can be applied before or after the event. For example, whenever a customer record is deleted, a
text line is added to a log table.
SQL transactions preserve the integrity of the DB by making sure all the statements in the block
execute before the changes are committed. If they are not then a rollback is called to restore the DB.

### Wednesday, August 10, 2016
Reviewed Spark in preparation for attending Boston Apache Spark meetup.

### Monday, August 15, 2016
ODBC is open database connectivity. It is a standard which specifies how an application with talk to
a database. It is needed because of the of the extensions to the ANSI SQL standard. An application
uses a database by using a driver, which is particular to the given database.

### Tuesday, August 16, 2016
Read chapter on cursors. Application development languages have to operate on a single row at
a time whereas SQL operates on the entire set of rows at a time. A cursor is like a pointer in
that when it is active you can select, update or delete the row.

Persistent stored modules where added between 1992 and 1999. They allow for function within
SQL.

void main {
  exec sql
    begin atomic
      insert into ...
    end;
}

Triggers are like signals. When one thing happens an event is triggered in response.

### Wednesday, August 17, 2016
Uploaded updated resume and CV to web page. Reviewed SQL.

### Thursday, August 18, 2016
select avg(o.price) from products o where
(select count(*) from products i where o.price > i.price) > 3 and
(select count(*) from products i where o.price > i.price) < (select count(*) from products) - 3;

select avg(o.price) from products o where
(select count(*) from products i where o.price > i.price) > 3 and
(select count(*) from products i where o.price < i.price) > 3;

select price, case when price > 25 then 0 else 1 end from products;

SELECT * FROM [Customers] c where exists (select * from suppliers s where s.city = c.city); // 8
SELECT * FROM [Customers] where city in (select city from suppliers); // 8
SELECT * FROM [Customers] where city in (select distinct city from suppliers); // 8
select * from customers where city in (SELECT city FROM [Customers] intersect select city from suppliers); // 8
SELECT c.* FROM [Customers] c inner join suppliers s using (city); // 8, used join instead of subquery

select * from customers where City like 'L%';

select * from customers inner join orders on orders.customerid=customers.customerid inner join shippers on shippers.shipperid=orders.shipperid where customers.city <> 'Helsinki' and orders.orderid > 10400;

select supplierid, avg(price) a from products group by supplierid having a < 20.5 order by a asc;

select upper(city) || 'TonyHawk', nullif(country, 'Germany'), trim(length(country)), coalesce(1, null, city, country, null), cast(customerid as char(80)) from customers;
