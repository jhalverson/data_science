Jonathan Halverson
Thursday, June 23, 2016
-----------------------

### Make sure to start the server through system preferences
jhalverson$ mysql -p // with the server running

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| test               |
+--------------------+
2 rows in set (0.06 sec)

mysql> use test;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| persons        |
| test_log       |
+----------------+
2 rows in set (0.00 sec)


mysql> describe test.persons;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| id          | int(11)      | NO   | PRI | 0       |       |
| description | varchar(255) | YES  |     | NULL    |       |
| ContactName | varchar(255) | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

mysql> select * from persons;
+----+-------------------------------+----------------+
| id | description                   | ContactName    |
+----+-------------------------------+----------------+
| 11 | Gas canisters                 | James Woodborn |
| 56 | Digital compass for dog sleds | Charlie Parker |
+----+-------------------------------+----------------+
2 rows in set (0.07 sec)


mysql> describe test_log;
+-------------+--------------+------+-----+-------------+----------------+
| Field       | Type         | Null | Key | Default     | Extra          |
+-------------+--------------+------+-----+-------------+----------------+
| id          | int(11)      | NO   | PRI | NULL        | auto_increment |
| message     | varchar(255) | YES  |     | NULL        |                |
| ContactName | varchar(100) | YES  |     | Joey Baggio |                |
+-------------+--------------+------+-----+-------------+----------------+
3 rows in set (0.01 sec)


### delete a table
mysql> drop table test_log;
Query OK, 0 rows affected (0.28 sec)

mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| persons        |
+----------------+
1 row in set (0.00 sec)


### I tried to load a csv file but it failed due to jhalverson not having access
### I was able to make the table as jhalverson, however
mysql> create table products (ID int, ProductName varchar(255), ContactName varchar(255), Price float);
Query OK, 0 rows affected (0.22 sec)

### I then logged in as root and was then able to load the CSV file
nanomines:mysql jhalverson$ mysql -u root -p

load data infile "/Users/jhalverson/data_science/sql_mysql/products.csv" into table products columns terminated by ',' lines terminated by '\n';


mysql> create table suppliers (ID int unsigned primary key auto_increment, Supplier char(80) not null, ProductName char(80) not null, ContactEmail char(80) default 'contact@host.com');
Query OK, 0 rows affected (0.06 sec)

mysql> insert into suppliers (Supplier, ProductName) values ('Chips chips', 'Straws');                                      Query OK, 1 row affected (0.00 sec)

mysql> select * from suppliers;
+----+-------------+-------------+------------------+
| ID | Supplier    | ProductName | ContactEmail     |
+----+-------------+-------------+------------------+
|  1 | Chips chips | Straws      | contact@host.com |
+----+-------------+-------------+------------------+
1 row in set (0.00 sec)

### Joins
#The INNER JOIN creates a new result table by combining column values of two
#tables (table1 and table2) based upon the join-predicate. The query
#A full join is equivalent to a left join union all right join.
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | Supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
+----+----------------------+-------------------+------------------------+
4 rows in set (0.00 sec)

mysql> select * from products;
+------+----------------+---------------+--------+
| ID   | ProductName    | ContactName   | Price  |
+------+----------------+---------------+--------+
|    1 | Knives         | Joe Smith     |  19.99 |
|    2 | Spoons         | Karen McGue   |   2.38 |
|    3 | Fishbone Forks | Captain Joe   | 121.34 |
|    4 | Straws         | Mitch Cohawke |  33.99 |
+------+----------------+---------------+--------+
4 rows in set (0.00 sec)

mysql> select * from products left join suppliers on products.productname=suppliers.productname;
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
| ID   | ProductName    | ContactName   | Price  | ID   | Supplier             | ProductName | ContactEmail        |
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
|    4 | Straws         | Mitch Cohawke |  33.99 |    1 | Chips chips          | Straws      | info@chipschips.com |
|    1 | Knives         | Joe Smith     |  19.99 |    2 | Bed, Bath and Beyond | Knives      | help@b3.com         |
|    2 | Spoons         | Karen McGue   |   2.38 | NULL | NULL                 | NULL        | NULL                |
|    3 | Fishbone Forks | Captain Joe   | 121.34 | NULL | NULL                 | NULL        | NULL                |
+------+----------------+---------------+--------+------+----------------------+-------------+---------------------+
4 rows in set (0.01 sec)

mysql> select * from products inner join suppliers on products.productname=suppliers.productname;
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
| ID   | ProductName | ContactName   | Price | ID | Supplier             | ProductName | ContactEmail        |
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
|    4 | Straws      | Mitch Cohawke | 33.99 |  1 | Chips chips          | Straws      | info@chipschips.com |
|    1 | Knives      | Joe Smith     | 19.99 |  2 | Bed, Bath and Beyond | Knives      | help@b3.com         |
+------+-------------+---------------+-------+----+----------------------+-------------+---------------------+
2 rows in set (0.00 sec)



### Here is an alternative to describe:

mysql> desc products;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| ID          | int(11)      | YES  |     | NULL    |       |
| ProductName | varchar(255) | YES  |     | NULL    |       |
| ContactName | varchar(255) | YES  |     | NULL    |       |
| Price       | float        | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
4 rows in set (0.16 sec)


### Unicode
Nvarchar versus varchar

### SQL provides a variety of math functions

### Having
# The GROUP BY clause follows the WHERE clause in a SELECT statement and precedes the ORDER BY clause.
select country, sum(CustomerID) as sumfunc from customers group by country having sumfunc > 100 and Country like 'U%' order by sumfunc; 
Country	sumfunc
UK	213
USA	796


### use SQL as a calculator
select 45.0/2.98;


### any and all
SQL> SELECT * FROM CUSTOMERS
WHERE AGE > ALL (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
+----+--------+-----+-----------+---------+
| ID | NAME   | AGE | ADDRESS   | SALARY  |
+----+--------+-----+-----------+---------+
|  1 | Ramesh |  32 | Ahmedabad | 2000.00 |
+----+--------+-----+-----------+---------+
1 row in set (0.02 sec)
SQL> SELECT * FROM CUSTOMERS
WHERE AGE > ANY (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);
+----+----------+-----+-----------+---------+
| ID | NAME     | AGE | ADDRESS   | SALARY  |
+----+----------+-----+-----------+---------+
|  1 | Ramesh   |  32 | Ahmedabad | 2000.00 |
|  2 | Khilan   |  25 | Delhi
|  4 | Chaitali |  25 | Mumbai
|  5 | Hardik   |  27 | Bhopal
+----+----------+-----+-----------+---------


### the like can be applied to numbers as well as text
select * from products where price like '_8';
# the percent symbol wildcard represents 0 or more characters


### Union, union all, intercept, except are all possible


### Started advanced operations
### Alter, truncate and other


### Create View view_name as select ...
# Note that a check clause can be added 
# There are many rules applied to views for updating and inserting rows
CREATE VIEW CUSTOMERS_VIEW AS
SELECT name, age FROM  CUSTOMERS WHERE age IS NOT NULL WITH CHECK OPTION;


### Monday, July 11, 2016
# If alias fails with where clase then use subquery (this is an inline view)
select * from (select productname, price as handle from products) as x where handle > 45 order by handle;

# concatenation in MySQL
select concat(description, '----', ContactName) from persons;
+-------------------------------------------------+
| concat(description, '----', ContactName)        |
+-------------------------------------------------+
| Gas canisters----James Woodborn                 |
| Digital compass for dog sleds----Charlie Parker |
+-------------------------------------------------+

# the case expression to add a column and use if-else
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | Supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
+----+----------------------+-------------------+------------------------+
5 rows in set (0.00 sec)

mysql> select productname, id, case when id > 75 then 'overpriced' when id <= 2 then 'underpriced' else 'okay' end as status from suppliers; 
+-------------------+----+-------------+
| productname       | id | status      |
+-------------------+----+-------------+
| Straws            |  1 | underpriced |
| Knives            |  2 | underpriced |
| Drill bits        |  3 | okay        |
| Ursula's Utensils |  4 | okay        |
| Manfrotto tripod  |  5 | okay        |
+-------------------+----+-------------+

# remove the not null constraint on a column
mysql> alter table suppliers modify supplier char(80) default null;

# replacing null in the result-set without changing the table
mysql> select * from suppliers;
+----+----------------------+-------------------+------------------------+
| ID | supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |
+----+----------------------+-------------------+------------------------+
7 rows in set (0.00 sec)

# the coalesce function returns the first non-null results from left to right; if nothing
# is found then it returns null
mysql> select coalesce(supplier, 0) from suppliers;
+-----------------------+
| coalesce(supplier, 0) |
+-----------------------+
| Chips chips           |
| Bed, Bath and Beyond  |
| Grossmans             |
| Fishbone Forks        |
| Boston Warehouse      |
| Bills Trucking        |
| 0                     |
+-----------------------+

SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0)) FROM Products;

# order by number of column
select * from products order by 6 desc; // 6th column

# order by second to last character
mysql> select * from suppliers order by substr(productname, length(productname) - 1);
+----+----------------------+-------------------+------------------------+
| ID | supplier             | ProductName       | ContactEmail           |
+----+----------------------+-------------------+------------------------+
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |
|  1 | Chips chips          | Straws            | info@chipschips.com    |
+----+----------------------+-------------------+------------------------+

# case statement for sorting

# Note: union will probabily internally use a sort to eliminiate duplicates

# using IN to select rows from a list of items from another table
select * from customers where customers.country in (select distinct suppliers.country from suppliers) order by customers.country;
select * from customers where customers.country not in (select distinct suppliers.country from suppliers) order by customers.country;

# wildcard select
select c.* from customers as c;


###Tuesday, July 12, 2016
# all, any, some
SELECT e1.empno, e1.sal
FROM   emp e1
WHERE  e1.sal > ALL (SELECT e2.sal
                     FROM   emp e2
                     WHERE  e2.deptno = 20);

# CLOB is a character large object -- maybe replaced by text
# There are five data types that deal with dates and times: date, time w/o time zone, timestamp w/o time zone
# Intervals analogous to timediff are available
# Row types breaks the rule of only one value per field
# First normal form
# Array and multiset is also possible Create table customer (Phone character varying (15) array[3]);
# Cardinality relates to array size
# REF is a pointer which can be dereferenced to obtain the actual contents
# UDT or user defined types are also possible - these are nice because one can match the data types
# of the host (application) with those of the database. UDT include distinct types and structured types
# Distinct types are like typedefs from C/C++
# XML can be stored
# Schemas contain tables and views


### Wednesday, July 13, 2016
# Adding a column dependent on current columns
select * from (select customername, city, case when city > 'L' then 0 else 1 end as city_flag from customers) as x where city_flag=1;
customername	city	city_flag
Alfreds Futterkiste	Berlin	1
Cactus Comidas para llevar	Buenos Aires	1
Chop-suey Chinese	Bern	1
Drachenblut Delikatessend	Aachen	1

# using an line case clause
select *, price*case when price < 10 then 0.1 when price < 20 then 1 when price > 20 then 1.6 end as scaled_price from products;

mysql> select *, power(id, 2) from suppliers;
+----+----------------------+-------------------+------------------------+--------------+
| ID | supplier             | ProductName       | ContactEmail           | power(id, 2) |
+----+----------------------+-------------------+------------------------+--------------+
|  1 | Chips chips          | Straws            | info@chipschips.com    |            1 |
|  2 | Bed, Bath and Beyond | Knives            | help@b3.com            |            4 |
|  3 | Grossmans            | Drill bits        | mike@mikegrossmans.com |            9 |
|  4 | Fishbone Forks       | Ursula's Utensils | ursula@mainz.de        |           16 |
|  5 | Boston Warehouse     | Manfrotto tripod  | contact@host.com       |           25 |
|  6 | Bills Trucking       | cargo service     | bill@billyboy.org      |           36 |
|  7 | NULL                 | Cargo service     | bill@billyboy.org      |           49 |
+----+----------------------+-------------------+------------------------+--------------+

# find common rows between tables
select * from charles # where charles is a view with rows in customers with customerid > 50
intersect
select * from customers;

# find rows in the first table which do not exist in the second
select * from customers
except
select * from charles;


### Friday, July 15, 2016
select categoryID, supplierid, avg(price), count(supplierid) from products where supplierid < 100 group by categoryID, supplierid having avg(price) > 25 order by categoryID desc;

# join with "using" instead of "on"
select * from customers join orders using (customerid);

A database contains catalogs which contain schemas which contain tables

CREATE SCHEMA SALES AUTHORIZATION SALES_MANAGER DEFAULT CHARACTER SET ASCII_FULL;

CREATE DOMAIN AGE AS INTEGER CHECK (AGE > 20)

DDL (data definition), DML (data manipulation lang), DCL (control)

Aggregate or set functions: avg, min, max, sum, count - these operate on columns instead
of the scalar functions.

DCL has commit, rollback, grant, revoke

Collation is how strings compare with one another for a given character set.

Composite keys as primary keys


### Monday, July 18, 2016
mysql> select county, avg(tiv_2012) from insur where county between 'A%' and 'H%' group by county having avg(tiv_2012) > 300000.0 order by county;
+------------------+----------------+
| county           | avg(tiv_2012)  |
+------------------+----------------+
| ALACHUA COUNTY   | 1021623.785457 |
| BAY COUNTY       | 3013689.310074 |
| BRADFORD COUNTY  | 1177371.827097 |
| BREVARD COUNTY   | 1939929.287844 |
| BROWARD COUNTY   | 2690955.647285 |
| CALHOUN COUNTY   |  715649.379706 |
| CHARLOTTE COUNTY | 1459168.163333 |
| CITRUS COUNTY    | 1018138.243984 |
| CLAY COUNTY      |  716967.506942 |
| COLLIER COUNTY   | 2419465.874003 |
| COLUMBIA COUNTY  | 1454704.909840 |
| DESOTO COUNTY    |  596621.362870 |
| DIXIE COUNTY     |  559451.452000 |
| DUVAL COUNTY     | 3262571.100011 |
| ESCAMBIA COUNTY  | 2309973.569818 |
| FLAGLER COUNTY   | 1152014.854167 |
| FRANKLIN COUNTY  |  756127.959730 |
| GADSDEN COUNTY   |  903971.397704 |
| GILCHRIST COUNTY |  314619.013333 |
| GLADES COUNTY    | 1010138.583636 |
| GULF COUNTY      |  854822.123472 |
+------------------+----------------+
21 rows in set (0.05 sec)

select policy_id, tiv_2011, tiv_2012 from insur where county = any(select county from insur where county like 'L%');


###Tuesday, July 19, 2016
# working with dates

mysql> select curdate();
+------------+
| curdate()  |
+------------+
| 2016-07-19 |
+------------+
1 row in set (0.00 sec)

mysql> select curtime();
+-----------+
| curtime() |
+-----------+
| 11:48:38  |
+-----------+
1 row in set (0.00 sec)

mysql> select now();
+---------------------+
| now()               |
+---------------------+
| 2016-07-19 11:48:45 |
+---------------------+
1 row in set (0.00 sec)

TIP: The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database.

For instance, the query "SELECT * FROM Orders WHERE OrderDate='2008-11-11'" will not return anything from
1	Geitost	2008-11-11 13:23:44
2	Camembert Pierrot	2008-11-09 15:45:21
3	Mozzarella di Giovanni	2008-11-11 11:12:01
4	Mascarpone Fabioli	2008-10-29 14:56:59

because the query is looking for dates with no time portion.

###
mysql> select * from orders where orderdate1 = '2016-07-19';
Empty set (0.00 sec)

mysql> select * from orders where orderdate2 = '2016-07-19';
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 |
+----+---------------------+------------+---------------------+-------+
1 row in set (0.00 sec)

mysql> select * from orders where orderdate3 = '2016-07-19';
Empty set (0.00 sec)
###

As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets complicated.

NOW()	Returns the current date and time
CURDATE()	Returns the current date
CURTIME()	Returns the current time
DATE()	Extracts the date part of a date or date/time expression
EXTRACT()	Returns a single part of a date/time
DATE_ADD()	Adds a specified time interval to a date
DATE_SUB()	Subtracts a specified time interval from a date
DATEDIFF()	Returns the number of days between two dates
DATE_FORMAT()	Displays date/time data in different formats

MySQL comes with the following data types for storing a date or a date/time value in the database:

DATE - format YYYY-MM-DD
DATETIME  - format: YYYY-MM-DD HH:MI:SS
TIMESTAMP - format: YYYY-MM-DD HH:MI:SS
YEAR - format YYYY or YY

select * from orders where orders.orderdate > '1996-09-04';
select avg(orderdate) from orders; 1996.2244897959183

mysql> select datediff('1999-05-22', '1996-07-11');
+--------------------------------------+
| datediff('1999-05-22', '1996-07-11') |
+--------------------------------------+
|                                 1045 |
+--------------------------------------+

mysql> select datediff('1996-07-11', '1999-05-22');
+--------------------------------------+
| datediff('1996-07-11', '1999-05-22') |
+--------------------------------------+
|                                -1045 |
+--------------------------------------+

mysql> select date_add('1996-07-11', interval 60 day);
+-----------------------------------------+
| date_add('1996-07-11', interval 60 day) |
+-----------------------------------------+
| 1996-09-09                              |
+-----------------------------------------+

mysql> select date_add('1996-07-11', interval (select datediff('1999-07-11', '1996-05-22')) day);
+------------------------------------------------------------------------------------+
| date_add('1996-07-11', interval (select datediff('1999-07-11', '1996-05-22')) day) |
+------------------------------------------------------------------------------------+
| 1999-08-30                                                                         |
+------------------------------------------------------------------------------------+

mysql> select EXTRACT(year from '1999-07-11') + 999;
+---------------------------------------+
| EXTRACT(year from '1999-07-11') + 999 |
+---------------------------------------+
|                                  2998 |
+---------------------------------------+

mysql> select extract(year from date('2014-11-22 13:23:44.657'));
+----------------------------------------------------+
| extract(year from date('2014-11-22 13:23:44.657')) |
+----------------------------------------------------+
|                                               2014 |
+----------------------------------------------------+

mysql> select DATE_FORMAT(NOW(),'%d %b %Y %T:%f');
+-------------------------------------+
| DATE_FORMAT(NOW(),'%d %b %Y %T:%f') |
+-------------------------------------+
| 19 Jul 2016 13:02:22:000000         |
+-------------------------------------+

mysql> select DATE_FORMAT('2014-11-22 13:23:44.657','%d %b %Y %T:%f');
+---------------------------------------------------------+
| DATE_FORMAT('2014-11-22 13:23:44.657','%d %b %Y %T:%f') |
+---------------------------------------------------------+
| 22 Nov 2014 13:23:44:657000                             |
+---------------------------------------------------------+

Even if DATETIME and TIMESTAMP return the same format, they work very differently. In an INSERT or UPDATE query, the TIMESTAMP automatically set itself to the current date and time. TIMESTAMP also accepts various formats, like YYYYMMDDHHMISS, YYMMDDHHMISS, YYYYMMDD, or YYMMDD.

# make a table with date/time data types
mysql> create table orders (id int primary key, orderdate1 timestamp, orderdate2 date, orderdate3 datetime, price float);

mysql> insert into orders values(1, now(), '2016-07-19', now(), 34.75);
Query OK, 1 row affected (0.02 sec)

mysql> insert into orders values(2, '2002-07-10 10:07:05', '2050-03-07', '2000-05-15 15:05:00', 12.50);
Query OK, 1 row affected (0.05 sec)

mysql> select * from orders;
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 |
+----+---------------------+------------+---------------------+-------+

mysql> desc orders;
+------------+-----------+------+-----+-------------------+-----------------------------+
| Field      | Type      | Null | Key | Default           | Extra                       |
+------------+-----------+------+-----+-------------------+-----------------------------+
| id         | int(11)   | NO   | PRI | NULL              |                             |
| orderdate1 | timestamp | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |
| orderdate2 | date      | YES  |     | NULL              |                             |
| orderdate3 | datetime  | YES  |     | NULL              |                             |
| price      | float     | YES  |     | NULL              |                             |
+------------+-----------+------+-----+-------------------+-----------------------------+

mysql> select * from orders where extract(year from date(orderdate1)) = 2012;
+----+---------------------+------------+---------------------+-------+
| id | orderdate1          | orderdate2 | orderdate3          | price |
+----+---------------------+------------+---------------------+-------+
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 |
+----+---------------------+------------+---------------------+-------+

mysql> select datediff(orderdate1, orderdate2) from orders;
+----------------------------------+
| datediff(orderdate1, orderdate2) |
+----------------------------------+
|                                0 |
|                           -17407 |
|                             2369 |
+----------------------------------+


mysql> select @x:=avg(orderdate2) from orders;
+---------------------+
| @x:=avg(orderdate2) |
+---------------------+
|  20237343.000000000 |
+---------------------+

mysql> select *, @x from orders;
+----+---------------------+------------+---------------------+-------+--------------------+
| id | orderdate1          | orderdate2 | orderdate3          | price | @x                 |
+----+---------------------+------------+---------------------+-------+--------------------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 | 20237343.000000000 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 | 20237343.000000000 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 | 20237343.000000000 |
+----+---------------------+------------+---------------------+-------+--------------------+

mysql> select *, @x - datediff(orderdate1, orderdate2) from orders;
+----+---------------------+------------+---------------------+-------+-----------------------------------------+
| id | orderdate1          | orderdate2 | orderdate3          | price | @x - datediff(orderdate1, orderdate2)   |
+----+---------------------+------------+---------------------+-------+-----------------------------------------+
|  1 | 2016-07-19 14:14:40 | 2016-07-19 | 2016-07-19 14:14:40 | 34.75 | 20237343.000000000000000000000000000000 |
|  2 | 2002-07-10 10:07:05 | 2050-03-07 | 2000-05-15 15:05:00 |  12.5 | 20254750.000000000000000000000000000000 |
|  3 | 2012-03-29 22:41:00 | 2005-10-03 | 2020-01-10 05:45:09 |   150 | 20234974.000000000000000000000000000000 |
+----+---------------------+------------+---------------------+-------+-----------------------------------------+


### Wednesday, July 20, 2016
On indexes, rows are stored in the order they are inserted. An index simply list the rows by a specific column in order and stores the row index as pointer to the table.

# only need table qualifier when column name is the same between tables
select customers.customerid, orderdate, Country from customers, orders using (customerid);

You can't update expressions in views; only columns in the underlying tables

select * from customers limit 10 offset 5;

Merge is a statement to conditionally insert values

Temporal data - PERIOD -> application time (which dept an employee worked in) vs. system time (bank transactions)

select city, case when city < 'D' then 1 when city < 'P' then 2 else 3 end as code from customers order by code;

select * from customers where customerid > (select avg(price) from products);

# select columns from tables [join] [where] [group by] [having] [order by]
select customerid, city, orderid from customers inner join orders using (customerid) where customerid > 50 and orderid > 10260;


### Thursday, July 21, 2016
select * from customers order by City, CustomerName desc, Address;
select * from customers order by 5, 2 desc, 4;
select * from products where price > 1.25 * (select avg(price) from products);
select * from products where price > 50 and not supplierid = 3;
null does not equal null (must use is null)

select price, price < 20, productid is null from products;
Price	price < 20	productid is null
18	1	0
19	1	0
10	1	0
22	0	0
21.35	0	0

To escape characters like _ and % use ! like '100!%'

Derived columns are like: select name, heigh, 2*height from bodies;
select productname || 'out' as concated from products where price between 3.5 and 75; // concatenation
select City || ', ' || Country as Address from customers;
select City || ', ' || trim(Country) as Address from customers; // chars are padded so use trim


### Friday, July 22, 2016
mysql> select county, substring(county from 3) from insur_ limit 3;
+----------------+--------------------------+
| county         | substring(county from 3) |
+----------------+--------------------------+
| BROWARD COUNTY | OWARD COUNTY             |
| CITRUS COUNTY  | TRUS COUNTY              |
| DUVAL COUNTY   | VAL COUNTY               |
+----------------+--------------------------+

mysql> select county, substring(county from 3 for 5) from insur_ limit 3;
+----------------+--------------------------------+
| county         | substring(county from 3 for 5) |
+----------------+--------------------------------+
| BROWARD COUNTY | OWARD                          |
| CITRUS COUNTY  | TRUS                           |
| DUVAL COUNTY   | VAL C                          |
+----------------+--------------------------------+

mysql> select distinct county from insur_ where county like 'b%'; // notice not case-sensitive for this SQL engine
+-----------------+
| county          |
+-----------------+
| BROWARD COUNTY  |
| BAY COUNTY      |
| BREVARD COUNTY  |
| BAKER COUNTY    |
| BRADFORD COUNTY |
+-----------------+

mysql> select county, char_length(county), length(county), character_length(county) from insur_ limit 5;
+-----------------+---------------------+----------------+--------------------------+
| county          | char_length(county) | length(county) | character_length(county) |
+-----------------+---------------------+----------------+--------------------------+
| BROWARD COUNTY  |                  14 |             14 |                       14 |
| CITRUS COUNTY   |                  13 |             13 |                       13 |
| DUVAL COUNTY    |                  12 |             12 |                       12 |
| OKALOOSA COUNTY |                  15 |             15 |                       15 |
| SARASOTA COUNTY |                  15 |             15 |                       15 |
+-----------------+---------------------+----------------+--------------------------+

# position returns the position of the first occurance of the substring
mysql> select distinct county, position('H CO' in county) from insur_ where position('H CO' in county) <> 0;
+---------------------+----------------------------+
| county              | position('H CO' in county) |
+---------------------+----------------------------+
| HILLSBOROUGH COUNTY |                         12 |
| PALM BEACH COUNTY   |                         10 |
+---------------------+----------------------------+

mysql> select current_user();
+----------------------+
| current_user()       |
+----------------------+
| jhalverson@localhost |
+----------------------+

mysql> select current_date;
+--------------+
| current_date |
+--------------+
| 2016-07-22   |
+--------------+

mysql> select DATE_ADD(current_date, INTERVAL 90 day);
+-----------------------------------------+
| DATE_ADD(current_date, INTERVAL 90 day) |
+-----------------------------------------+
| 2016-10-20                              |
+-----------------------------------------+

# cast
select cast(price as integer) from products;
select cast(tiv_2012 as signed) from insur_; // Use signed instead of integer in MySQL

mysql> select char_length(cast(tiv_2012 as char(20))) from insur_ limit 5;
+-----------------------------------------+
| char_length(cast(tiv_2012 as char(20))) |
+-----------------------------------------+
|                                       8 |
|                                       7 |
|                                       9 |
|                                       8 |
|                                       9 |
+-----------------------------------------+

mysql> select county, case when position('BRO' in county) <> 0 then 'Bro' else 'Not Bro' end from insur_ limit 5;
+-----------------+------------------------------------------------------------------------+
| county          | case when position('BRO' in county) <> 0 then 'Bro' else 'Not Bro' end |
+-----------------+------------------------------------------------------------------------+
| BROWARD COUNTY  | Bro                                                                    |
| CITRUS COUNTY   | Not Bro                                                                |
| DUVAL COUNTY    | Not Bro                                                                |
| OKALOOSA COUNTY | Not Bro                                                                |
| SARASOTA COUNTY | Not Bro                                                                |
+-----------------+------------------------------------------------------------------------+

# successive joins or chaining
select * from customers inner join orders on customers.customerid=orders.customerid and customers.customerid > 50 inner join orderdetails on orderdetails.orderid=orders.orderid;


# join with and condition
select * from customers inner join orders on customers.customerid=orders.customerid and customers.customerid > 50;

nullif is useful to replace -1 or 99 or 'N/A' with null
Ex: select nullif(job, -1) this returns null if job is -1 or job is it is not equal to -1

A domain is a set of permissible values for a column.

# joins (Chapter 7)
select * from customers natural join orders natural join shippers; // compares columns with the same name for equality


### Monday, July 25, 2016
A null is not a match when joining.

The cross join is the Cartesian product or every row with every row.

The using clause is similar to natural join except with using you can specify which columns
should match whereas with natural it will compare all columns with the same name for equality.
select * from table1 join_type table2 using (column1, column2);

Use cross join or Cartesian product: select * from table1 cross join table 2;
Be wary of natural joins because if column names are renamed then previously written scripts can fail.

Join is equivalent to inner join since it is the most common.

inner join on t.price * t.sales > 10 * r.advance and t.title_id = r.title_id
and t.title_id = r.title_id; // list books whose revenue is ten times larger than its advance
